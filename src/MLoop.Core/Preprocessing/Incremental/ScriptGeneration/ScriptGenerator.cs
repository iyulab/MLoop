using System.Text;
using Microsoft.Extensions.Logging;
using MLoop.Core.Preprocessing.Incremental.RuleDiscovery.Models;
using MLoop.Core.Preprocessing.Incremental.ScriptGeneration.Contracts;
using MLoop.Core.Preprocessing.Incremental.ScriptGeneration.Models;

namespace MLoop.Core.Preprocessing.Incremental.ScriptGeneration;

/// <summary>
/// Generates reusable C# preprocessing scripts from approved rules.
/// </summary>
public sealed class ScriptGenerator : IScriptGenerator
{
    private readonly ILogger<ScriptGenerator> _logger;

    public ScriptGenerator(ILogger<ScriptGenerator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public string GenerateScript(
        IReadOnlyList<PreprocessingRule> rules,
        ScriptGenerationOptions? options = null)
    {
        options ??= new ScriptGenerationOptions();

        _logger.LogInformation("Generating preprocessing script with {RuleCount} rules", rules.Count);

        var sb = new StringBuilder();

        // Generate header
        GenerateHeader(sb, options);

        // Generate namespace and class
        GenerateClassDeclaration(sb, options);

        // Generate Apply method
        GenerateApplyMethod(sb, rules, options);

        // Generate helper methods for each rule type
        GenerateHelperMethods(sb, rules, options);

        // Close class and namespace
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var script = sb.ToString();

        _logger.LogInformation("Script generation complete. Total lines: {LineCount}",
            script.Split('\n').Length);

        return script;
    }

    /// <inheritdoc />
    public async Task SaveScriptAsync(
        string script,
        string outputPath,
        CancellationToken cancellationToken = default)
    {
        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(outputPath, script, cancellationToken);

        _logger.LogInformation("Script saved to: {Path}", outputPath);
    }

    /// <inheritdoc />
    public async Task GenerateAndSaveAsync(
        IReadOnlyList<PreprocessingRule> rules,
        string outputPath,
        ScriptGenerationOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        var script = GenerateScript(rules, options);
        await SaveScriptAsync(script, outputPath, cancellationToken);
    }

    // ===== Code Generation Methods =====

    private void GenerateHeader(StringBuilder sb, ScriptGenerationOptions options)
    {
        if (options.IncludeComments)
        {
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// This file was generated by MLoop on {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
            sb.AppendLine("// Reusable preprocessing script based on approved rules");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
        }

        // Using statements
        sb.AppendLine("using Microsoft.Data.Analysis;");

        if (options.IncludeLogging)
        {
            sb.AppendLine("using Microsoft.Extensions.Logging;");
        }

        sb.AppendLine();
    }

    private void GenerateClassDeclaration(StringBuilder sb, ScriptGenerationOptions options)
    {
        sb.AppendLine($"namespace {options.Namespace};");
        sb.AppendLine();

        if (options.IncludeComments)
        {
            sb.AppendLine("/// <summary>");
            sb.AppendLine("/// Applies preprocessing rules to clean and transform data.");
            sb.AppendLine("/// </summary>");
        }

        var sealedModifier = options.SealedClass ? "sealed " : "";
        sb.AppendLine($"public {sealedModifier}class {options.ClassName}");
        sb.AppendLine("{");

        if (options.IncludeLogging)
        {
            sb.AppendLine("    private readonly ILogger _logger;");
            sb.AppendLine();
            sb.AppendLine($"    public {options.ClassName}(ILogger<{options.ClassName}> logger)");
            sb.AppendLine("    {");
            sb.AppendLine("        _logger = logger ?? throw new ArgumentNullException(nameof(logger));");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private void GenerateApplyMethod(
        StringBuilder sb,
        IReadOnlyList<PreprocessingRule> rules,
        ScriptGenerationOptions options)
    {
        if (options.IncludeComments)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Applies all preprocessing rules to the input DataFrame.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"data\">The DataFrame to preprocess.</param>");
            sb.AppendLine("    /// <returns>The preprocessed DataFrame.</returns>");
        }

        var asyncModifier = options.GenerateAsync ? "async Task<DataFrame>" : "DataFrame";
        var awaitKeyword = options.GenerateAsync ? "await " : "";

        sb.AppendLine($"    public {asyncModifier} Apply(DataFrame data)");
        sb.AppendLine("    {");

        if (options.IncludeValidation)
        {
            sb.AppendLine("        if (data == null)");
            sb.AppendLine("        {");
            sb.AppendLine("            throw new ArgumentNullException(nameof(data));");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        if (options.IncludeLogging)
        {
            sb.AppendLine($"        _logger.LogInformation(\"Starting preprocessing with {rules.Count} rules\");");
            sb.AppendLine();
        }

        // Generate method calls for each rule
        for (var i = 0; i < rules.Count; i++)
        {
            var rule = rules[i];
            var methodName = GenerateMethodName(rule, i);

            if (options.IncludeComments)
            {
                sb.AppendLine($"        // Rule {i + 1}: {rule.Description}");
            }

            sb.AppendLine($"        {awaitKeyword}{methodName}(data);");
            sb.AppendLine();
        }

        if (options.IncludeLogging)
        {
            sb.AppendLine("        _logger.LogInformation(\"Preprocessing complete\");");
            sb.AppendLine();
        }

        sb.AppendLine("        return data;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateHelperMethods(
        StringBuilder sb,
        IReadOnlyList<PreprocessingRule> rules,
        ScriptGenerationOptions options)
    {
        for (var i = 0; i < rules.Count; i++)
        {
            var rule = rules[i];
            var methodName = GenerateMethodName(rule, i);

            if (options.IncludeComments)
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// {rule.Description}");
                sb.AppendLine($"    /// </summary>");
            }

            var asyncModifier = options.GenerateAsync ? "async Task" : "void";

            sb.AppendLine($"    private {asyncModifier} {methodName}(DataFrame data)");
            sb.AppendLine("    {");

            // Generate method body based on rule type
            GenerateMethodBody(sb, rule, options);

            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private void GenerateMethodBody(
        StringBuilder sb,
        PreprocessingRule rule,
        ScriptGenerationOptions options)
    {
        // Placeholder implementation for each rule type
        // In actual implementation, this would generate specific code for each rule

        switch (rule.Type)
        {
            case PreprocessingRuleType.MissingValueStrategy:
                GenerateMissingValueCode(sb, rule, options);
                break;

            case PreprocessingRuleType.OutlierHandling:
                GenerateOutlierHandlingCode(sb, rule, options);
                break;

            case PreprocessingRuleType.WhitespaceNormalization:
                GenerateWhitespaceNormalizationCode(sb, rule, options);
                break;

            case PreprocessingRuleType.DateFormatStandardization:
                GenerateDateFormatStandardizationCode(sb, rule, options);
                break;

            case PreprocessingRuleType.CategoryMapping:
                GenerateCategoryMappingCode(sb, rule, options);
                break;

            case PreprocessingRuleType.TypeConversion:
                GenerateTypeConversionCode(sb, rule, options);
                break;

            default:
                sb.AppendLine($"        // TODO: Implement {rule.Type} logic");
                sb.AppendLine($"        // {rule.Description}");
                break;
        }
    }

    private string GenerateMethodName(PreprocessingRule rule, int index)
    {
        // Generate a safe C# method name from the rule
        var typeName = rule.Type.ToString();
        var columnName = rule.ColumnNames.Count > 0
            ? string.Join("_", rule.ColumnNames).Replace(" ", "").Replace("-", "_")
            : "Column";

        return $"Apply{typeName}_{columnName}_{index}";
    }

    // ===== Rule-Specific Code Generators =====

    private void GenerateMissingValueCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement missing value strategy");
        sb.AppendLine($"        // Strategy: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Process column: {column}");
        }
    }

    private void GenerateOutlierHandlingCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement outlier handling");
        sb.AppendLine($"        // Strategy: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Process column: {column}");
        }
    }

    private void GenerateWhitespaceNormalizationCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement whitespace normalization");
        sb.AppendLine($"        // Rule: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Normalize column: {column}");
        }
    }

    private void GenerateDateFormatStandardizationCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement date format standardization");
        sb.AppendLine($"        // Rule: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Standardize column: {column}");
        }
    }

    private void GenerateCategoryMappingCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement category mapping");
        sb.AppendLine($"        // Rule: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Map categories in column: {column}");
        }
    }

    private void GenerateTypeConversionCode(StringBuilder sb, PreprocessingRule rule, ScriptGenerationOptions options)
    {
        sb.AppendLine("        // Placeholder: Implement type conversion");
        sb.AppendLine($"        // Rule: {rule.Description}");
        foreach (var column in rule.ColumnNames)
        {
            sb.AppendLine($"        // Convert column: {column}");
        }
    }
}
