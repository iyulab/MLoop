using System.Text;
using MLoop.Extensibility.Preprocessing;

namespace MLoop.Core.DataQuality;

/// <summary>
/// Generates preprocessing scripts from data quality analysis results.
/// Converts DataQualityIssue findings into executable IPreprocessingScript C# code.
/// </summary>
public class PreprocessingScriptGenerator
{
    private readonly ILogger _logger;

    public PreprocessingScriptGenerator(ILogger logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Generates a preprocessing script from detected quality issues.
    /// </summary>
    /// <param name="issues">List of data quality issues to address</param>
    /// <param name="scriptName">Name for the generated script class</param>
    /// <returns>C# source code for IPreprocessingScript implementation</returns>
    public string GenerateScript(List<DataQualityIssue> issues, string scriptName = "AutoGeneratedPreprocessingScript")
    {
        var sb = new StringBuilder();

        // File header and usings
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using MLoop.Extensibility.Preprocessing;");
        sb.AppendLine();

        // Class and summary
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated preprocessing script to address detected data quality issues:");
        foreach (var issue in issues.Where(i => i.Severity == IssueSeverity.High || i.Severity == IssueSeverity.Critical))
        {
            sb.AppendLine($"/// - {issue.Type}: {issue.Description}");
        }
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public class {scriptName} : IPreprocessingScript");
        sb.AppendLine("{");

        // ExecuteAsync method
        sb.AppendLine("    public async Task<PreprocessingResult> ExecuteAsync(PreprocessingContext context)");
        sb.AppendLine("    {");
        sb.AppendLine("        context.Logger.Info(\"üîß Auto-Generated Preprocessing: Fixing data quality issues\");");
        sb.AppendLine();
        sb.AppendLine("        var inputPath = context.InputPath;");
        sb.AppendLine("        var outputPath = context.GetTempPath(\"processed.csv\");");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        // Group issues by type and generate appropriate transformations
        var hasEncodingIssue = issues.Any(i => i.Type == DataQualityIssueType.EncodingIssue);
        var hasDuplicates = issues.Any(i => i.Type == DataQualityIssueType.DuplicateRows);
        var hasWhitespace = issues.Any(i => i.Type == DataQualityIssueType.WhitespaceIssues);

        if (hasEncodingIssue)
        {
            sb.AppendLine("            // Fix encoding issues");
            sb.AppendLine("            var encoding = await DetectEncodingAsync(inputPath);");
            sb.AppendLine("            if (encoding != Encoding.UTF8)");
            sb.AppendLine("            {");
            sb.AppendLine("                var content = await File.ReadAllTextAsync(inputPath, encoding);");
            sb.AppendLine("                await File.WriteAllTextAsync(outputPath, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));");
            sb.AppendLine("                context.Logger.Info($\"  ‚úì Converted {encoding.EncodingName} ‚Üí UTF-8\");");
            sb.AppendLine("                inputPath = outputPath;  // Chain transformations");
            sb.AppendLine("                outputPath = context.GetTempPath(\"processed2.csv\");");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // For other issues, we'll use simple CSV processing
        if (hasDuplicates || hasWhitespace)
        {
            sb.AppendLine("            // Read CSV");
            sb.AppendLine("            var lines = await File.ReadAllLinesAsync(inputPath);");
            sb.AppendLine("            var header = lines[0];");
            sb.AppendLine("            var rows = lines.Skip(1).ToList();");
            sb.AppendLine();

            if (hasDuplicates)
            {
                sb.AppendLine("            // Remove duplicates");
                sb.AppendLine("            var originalCount = rows.Count;");
                sb.AppendLine("            rows = rows.Distinct().ToList();");
                sb.AppendLine("            context.Logger.Info($\"  ‚úì Removed {originalCount - rows.Count} duplicate rows\");");
                sb.AppendLine();
            }

            if (hasWhitespace)
            {
                sb.AppendLine("            // Trim whitespace");
                sb.AppendLine("            rows = rows.Select(row => string.Join(\",\", ");
                sb.AppendLine("                row.Split(',').Select(cell => cell.Trim()))).ToList();");
                sb.AppendLine("            context.Logger.Info(\"  ‚úì Trimmed whitespace from all columns\");");
                sb.AppendLine();
            }

            sb.AppendLine("            // Write cleaned CSV");
            sb.AppendLine("            await File.WriteAllLinesAsync(outputPath, new[] { header }.Concat(rows));");
        }
        else if (!hasEncodingIssue)
        {
            // No transformations needed
            sb.AppendLine("            // No critical issues detected, pass through");
            sb.AppendLine("            outputPath = inputPath;");
        }

        sb.AppendLine();
        sb.AppendLine("            context.Logger.Info($\"  üíæ Saved: {outputPath}\");");
        sb.AppendLine();
        sb.AppendLine("            return new PreprocessingResult");
        sb.AppendLine("            {");
        sb.AppendLine("                OutputPath = outputPath,");
        sb.AppendLine("                Success = true,");
        sb.AppendLine($"                Message = \"Fixed {issues.Count} data quality issue(s)\"");
        sb.AppendLine("            };");

        // Catch block
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine("            context.Logger.Error($\"‚ùå Preprocessing failed: {ex.Message}\");");
        sb.AppendLine("            return new PreprocessingResult");
        sb.AppendLine("            {");
        sb.AppendLine("                OutputPath = inputPath,");
        sb.AppendLine("                Success = false,");
        sb.AppendLine("                Message = $\"Preprocessing failed: {ex.Message}\"");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        // Helper methods if needed
        if (hasEncodingIssue)
        {
            sb.AppendLine();
            sb.AppendLine("    private async Task<Encoding> DetectEncodingAsync(string filePath)");
            sb.AppendLine("    {");
            sb.AppendLine("        var buffer = new byte[4096];");
            sb.AppendLine("        int bytesRead;");
            sb.AppendLine();
            sb.AppendLine("        using (var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))");
            sb.AppendLine("        {");
            sb.AppendLine("            bytesRead = await fs.ReadAsync(buffer, 0, buffer.Length);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Check for UTF-8 BOM");
            sb.AppendLine("        if (bytesRead >= 3 && buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF)");
            sb.AppendLine("            return Encoding.UTF8;");
            sb.AppendLine();
            sb.AppendLine("        // Check for UTF-16 LE BOM");
            sb.AppendLine("        if (bytesRead >= 2 && buffer[0] == 0xFF && buffer[1] == 0xFE)");
            sb.AppendLine("            return Encoding.Unicode;");
            sb.AppendLine();
            sb.AppendLine("        // Check for UTF-16 BE BOM");
            sb.AppendLine("        if (bytesRead >= 2 && buffer[0] == 0xFE && buffer[1] == 0xFF)");
            sb.AppendLine("            return Encoding.BigEndianUnicode;");
            sb.AppendLine();
            sb.AppendLine("        // Try UTF-8 validation");
            sb.AppendLine("        try");
            sb.AppendLine("        {");
            sb.AppendLine("            var decoder = Encoding.UTF8.GetDecoder();");
            sb.AppendLine("            var chars = new char[bytesRead];");
            sb.AppendLine("            decoder.Convert(buffer, 0, bytesRead, chars, 0, bytesRead, false, out _, out _, out _);");
            sb.AppendLine("            return Encoding.UTF8;");
            sb.AppendLine("        }");
            sb.AppendLine("        catch");
            sb.AppendLine("        {");
            sb.AppendLine("            return Encoding.GetEncoding(\"Windows-1252\");");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Saves a generated script to a file.
    /// </summary>
    /// <param name="scriptContent">Generated script source code</param>
    /// <param name="outputPath">File path to save the script</param>
    public async Task SaveScriptAsync(string scriptContent, string outputPath)
    {
        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(outputPath, scriptContent);
        _logger.Info($"üíæ Generated preprocessing script: {outputPath}");
    }

    /// <summary>
    /// Analyzes data and generates a preprocessing script if issues are found.
    /// </summary>
    /// <param name="csvPath">Path to CSV file to analyze</param>
    /// <param name="outputScriptPath">Path where script should be saved</param>
    /// <param name="labelColumn">Optional label column for analysis</param>
    /// <returns>True if script was generated, false if no issues found</returns>
    public async Task<bool> AnalyzeAndGenerateAsync(string csvPath, string outputScriptPath, string? labelColumn = null)
    {
        var analyzer = new DataQualityAnalyzer(_logger);
        var issues = await analyzer.AnalyzeAsync(csvPath, labelColumn);

        // Only generate script for High or Critical issues
        var criticalIssues = issues
            .Where(i => i.Severity == IssueSeverity.High || i.Severity == IssueSeverity.Critical)
            .ToList();

        if (criticalIssues.Count == 0)
        {
            _logger.Info("‚úÖ No critical data quality issues detected");
            return false;
        }

        _logger.Info($"‚ö†Ô∏è  Found {criticalIssues.Count} critical data quality issue(s):");
        foreach (var issue in criticalIssues)
        {
            _logger.Info($"  - {issue}");
        }

        var scriptName = Path.GetFileNameWithoutExtension(outputScriptPath)
            .Replace("-", "_")
            .Replace(" ", "_");

        var scriptContent = GenerateScript(criticalIssues, scriptName);
        await SaveScriptAsync(scriptContent, outputScriptPath);

        return true;
    }
}
